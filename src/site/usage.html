<!DOCTYPE HTML>
<html>
<head>
	<meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
	<title>Examples - Aika</title>
	<link rel="stylesheet" href="css/style.css" type="text/css">
	<link rel="shortcut icon" href="images/favicon.png" />
	<script src="https://cdn.rawgit.com/google/code-prettify/master/loader/run_prettify.js"></script>

    <script>
        (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
                    (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
                m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
        })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

        ga('create', 'UA-77552310-1', 'auto');
        ga('send', 'pageview');

    </script>
</head>
<body>
<div id="header">
	<div>
		<div class="logo">
			<a href="index.html"></a>
		</div>
		<ul id="navigation">
			<li>
				<a href="index.html">Overall idea</a>
			</li>
            <li>
                <a href="inference.html">Inference</a>
            </li>
            <li>
                <a href="training.html">Training</a>
            </li>
			<li class="active">
				<a href="usage.html">Examples</a>
			</li>
			<li>
				<a href="resources.html">Resources</a>
			</li>
            <li>
                <a href="https://github.com/aika-algorithm/aika">GitHub</a>
            </li>
		</ul>
	</div>
</div>
	<div id="contents">
		<div class="features">
            <h1>Usage</h1>

            <h3>Maven POM</h3>
            <p>
                The following dependency includes the Aika software library to an existing maven project.
            </p>

            <p>
                <b>
                &lt;dependency&gt;<br/>
                &nbsp;&nbsp;&nbsp;&nbsp;&lt;groupId&gt;org.aika-software&lt;&#47;groupId&gt;<br/>
                &nbsp;&nbsp;&nbsp;&nbsp;&lt;artifactId&gt;aika&lt;&#47;artifactId&gt;<br/>
                &nbsp;&nbsp;&nbsp;&nbsp;&lt;version&gt;0.16&lt;&#47;version&gt;<br/>
                &lt;&#47;dependency&gt;<br/>
                </b>
            </p>


            <h3>Named Entity Recognition / Entity Resolution example</h3>
            <p>
                This example demonstrates the recognition of the words 'jackson cook' as forename and surname.
                If these words would have occurred independently, they would have been recognized as city or
                profession based on the example code. The complete code for this example can be found in the class <a href="https://github.com/aika-algorithm/aika/blob/master/src/test/java/org/aika/network/NamedEntityRecognitionTest.java">NamedEntityRecognitionTest</a>.
                <br/>
                Now, the first step is to create an empty model. The following map is used as a dictionary to look up the individual word input neurons.
            </p>
            <div class="prettyprint-code">
            <pre class="prettyprint">
				<code class="language-java">
    Model m = new Model();

    HashMap&lt;String, Neuron&gt; inputNeurons = new HashMap<>();

    for(String word: new String[] {"jackson", "cook"}) {
        Neuron in = m.createNeuron("W-" + word);

        inputNeurons.put(word, in);
    }
                </code>
			</pre>
            </div>
            <p>
                These three neurons are just placeholders that will be wired up later on.
            </p>
            <div class="prettyprint-code">
            <pre class="prettyprint">
				<code class="language-java">
    Neuron forenameCategory = m.createNeuron("C-forename");
    Neuron surnameCategory = m.createNeuron("C-surname");
    Neuron inhibitingN = m.createNeuron("INHIB");
                </code>
			</pre>
            </div>

            <p>
                The following code snippet is the crucial section of this example. It shows how the first entity neuron is created and connected by its input synapses.
                The entity neurons represent the concrete meanings of the input words. As can be seen here the individual inputs have a few more properties than we are used to from other
                neural networks. The reason for this is that Aika not only propagates the input activation value to the next neuron but also the text range, the word position.
                <br/>
                This entity neuron has three inputs. The first one simply checks if the word 'cook' occurred in the text. The second one is a positive feedback loop and checks if the previous word
                was a forename. The last one is a negative feedback loop. It makes sure that only one meaning is assigned to each word.
                <br/>
                The other entity neurons are created in a similar fashion which is therefore not shown here.
            </p>
            <div class="prettyprint-code">
            <pre class="prettyprint">
				<code class="language-java">
    Neuron cookSurnameEntity = Neuron.init(
            m.createNeuron("E-cook (surname)"),
            3.0, // adjusts the bias
            RECTIFIED_HYPERBOLIC_TANGENT_KEY,
            INeuron.Type.EXCITATORY,
            new Synapse.Builder() // Requires the word to be recognized
                    .setNeuron(inputNeurons.get("cook"))
                    .setWeight(10.0)
                    // This input requires the input activation to have an
                    // activation value of at least 0.9
                    .setBias(-10.0)
                    .setRelativeRid(0) // references the current word
                    .setRecurrent(false)
                    .setRangeMatch(EQUALS)
                    .setRangeOutput(true),
            new Synapse.Builder() // The previous word needs to be a forename
                    .setNeuron(forenameCategory)
                    .setWeight(5.0)
                    .setBias(0.0)
                    .setRelativeRid(-1) // references the previous word
                    .setRecurrent(true) // this input is a positive feedback loop
                    .setRangeMatch(NONE)
                    .setRangeOutput(false),

                    // This neuron may be suppressed by the E-cook (profession) neuron, but there is no
                    // self suppression taking place even though 'E-cook (surname)' is also contained
                    // in the inhibitingN.
            new Synapse.Builder()
                    .setNeuron(inhibitingN)
                    .setWeight(-100.0)
                    .setBias(0.0)
                    .setRecurrent(true) // this input is a negative feedback loop
                    .setRangeMatch(CONTAINS)
    );
                </code>
			</pre>
            </div>
            <p>
                The category neurons in this example only have input. For a real application there would be a long list of inputs.
            </p>
            <div class="prettyprint-code">
            <pre class="prettyprint">
				<code class="language-java">
    Neuron.init(
            forenameCategory,
            0.0,
            RECTIFIED_LINEAR_UNIT_KEY,
            INeuron.Type.EXCITATORY,
            new Synapse.Builder() // In this example there is only one forename considered.
                    .setNeuron(jacksonForenameEntity)
                    .setWeight(1.0)
                    .setBias(0.0)
                    .setRelativeRid(0)
                    .setRangeMatch(EQUALS)
                    .setRangeOutput(true)
    );
    Neuron.init(
            surnameCategory,
            0.0,
            RECTIFIED_LINEAR_UNIT_KEY,
            INeuron.Type.EXCITATORY,
            new Synapse.Builder()
                    .setNeuron(cookSurnameEntity)
                    .setWeight(1.0)
                    .setBias(0.0)
                    .setRelativeRid(0)
                    .setRangeMatch(EQUALS)
                    .setRangeOutput(true)
    );
                </code>
			</pre>
            </div>
            <p>
                The last neuron is the suppressing neuron. It is used as a mediator in order to avoid having to connect all of these neurons with each other. Self suppression does not take place.
            </p>
            <div class="prettyprint-code">
            <pre class="prettyprint">
				<code class="language-java">
    Neuron.init(
            inhibitingN,
            0.0,
            RECTIFIED_LINEAR_UNIT_KEY,
            INeuron.Type.INHIBITORY,
            new Synapse.Builder().setNeuron(cookProfessionEntity)
                    .setWeight(1.0)
                    .setBias(0.0)
                    .setRangeMatch(EQUALS)
                    .setRangeOutput(true),
            new Synapse.Builder()
                    .setNeuron(cookSurnameEntity)
                    .setWeight(1.0)
                    .setBias(0.0)
                    .setRangeMatch(EQUALS)
                    .setRangeOutput(true),
            new Synapse.Builder()
                    .setNeuron(jacksonCityEntity)
                    .setWeight(1.0)
                    .setBias(0.0)
                    .setRangeMatch(EQUALS)
                    .setRangeOutput(true),
            new Synapse.Builder()
                    .setNeuron(jacksonForenameEntity)
                    .setWeight(1.0)
                    .setBias(0.0)
                    .setRangeMatch(EQUALS)
                    .setRangeOutput(true)
        );
                </code>
			</pre>
            </div>
            <p>
                Now that the model is complete, we can start processing an actual text.
            </p>
            <div class="prettyprint-code">
            <pre class="prettyprint">
				<code class="language-java">
    Document doc = m.createDocument("mr. jackson cook was born in new york ");

    int i = 0;
    int wordPos = 0;
    for(String w: doc.getContent().split(" ")) {
        int j = i + w.length();

        // Feed the individual words as inputs into the network.
        inputNeurons.get(w).addInput(doc, i, j, wordPos);
        i = j + 1;
        wordPos++;
    }

    // Search for the best interpretation of this text.
    doc.process();

    System.out.println(doc.activationsToString());

    doc.clearActivations();
                </code>
			</pre>
            </div>
            <p>
The output of this example looks as following. Each line in the table represents a neuron activation.
            </p>
            <div class="prettyprint-code">
            <pre class="prettyprint">
				<code class="language-java">
// Activation ID - Final Decision - Range - Neuron Label - Relational ID (Word Pos.) - Upper Bound
// - Final Value | Final Weight | Final Norm - Input Value | Target Value

    ...
7  - SELECTED - (4,11)  - INHIB                - RID:null - UB:2.0 - V:1.0 W:0.0 N:0.0
3  - EXCLUDED - (4,11)  - E-jackson (city)     - RID:null - UB:1.0 -
10 - SELECTED - (4,11)  - C-forename           - RID:1    - UB:1.0 - V:1.0 W:0.0 N:0.0
1  - SELECTED - (4,11)  - W-jackson            - RID:1    - UB:1.0 - V:1.0 W:0.0 N:0.0 - IV:1.0
5  - SELECTED - (4,11)  - E-jackson (forename) - RID:1    - UB:1.0 - V:1.0 W:8.0 N:8.0
20 - SELECTED - (12,16) - INHIB                - RID:null - UB:2.0 - V:1.0 W:0.0 N:0.0
16 - EXCLUDED - (12,16) - E-cook (profession)  - RID:null - UB:1.0 -
23 - SELECTED - (12,16) - C-surname            - RID:2    - UB:1.0 - V:1.0 W:0.0 N:0.0
14 - SELECTED - (12,16) - W-cook               - RID:2    - UB:1.0 - V:1.0 W:0.0 N:0.0 - IV:1.0
18 - SELECTED - (12,16) - E-cook (surname)     - RID:2    - UB:1.0 - V:1.0 W:8.0 N:8.0
    ...

 Final SearchNode:27  WeightSum:W:16.0 N:26.0
                </code>
			</pre>
            </div>

            <br/>
            <br/>

            <h3>Mutual exclusion example</h3>
            <div style="text-align:center; width:100%">
                <img src="images/code-example-mutual-exclusion.svg" width="50%" height="50%" style="float:none; margin-left:auto; margin-right:auto; display:block"/>
            </div>

            <div class="prettyprint-code">
			<pre class="prettyprint">
				<code class="language-java">
    @Test
    public void testMutualExclusion() {
        Model m = new Model();

        // Create the input neurons for the network.
        Neuron inA = m.createNeuron("IN-A");
        Neuron inB = m.createNeuron("IN-B");
        Neuron inC = m.createNeuron("IN-C");

        // Instantiate the inhibitory neuron. Its inputs will be added later on.
        Neuron inhibN = m.createNeuron("INHIB");

        // Create three neurons that might be suppressed by the inhibitory neuron.
        Neuron pA = Neuron.init(
                m.createNeuron("A"),
                3.0,
                RECTIFIED_HYPERBOLIC_TANGENT_KEY,
                INeuron.Type.EXCITATORY,
                new Synapse.Builder()
                        .setNeuron(inA)
                        .setWeight(10.0)
                        .setBias(-10.0)
                        .setRecurrent(false)
                        .setRangeMatch(Range.Relation.EQUALS)
                        .setRangeOutput(true),
                new Synapse.Builder()
                        .setNeuron(inhibN)
                        .setWeight(-100.0)
                        .setBias(0.0)
                        .setRecurrent(true)
                        .setRangeMatch(Range.Relation.EQUALS)
        );

        Neuron pB = Neuron.init(
                m.createNeuron("B"),
                5.0,
                RECTIFIED_HYPERBOLIC_TANGENT_KEY,
                INeuron.Type.EXCITATORY,
                new Synapse.Builder()
                        .setNeuron(inB)
                        .setWeight(10.0)
                        .setBias(-10.0)
                        .setRecurrent(false)
                        .setRangeMatch(Range.Relation.EQUALS)
                        .setRangeOutput(true),
                new Synapse.Builder()
                        .setNeuron(inhibN)
                        .setWeight(-100.0)
                        .setBias(0.0)
                        .setRecurrent(true)
                        .setRangeMatch(Range.Relation.EQUALS)
        );

        Neuron pC = Neuron.init(
                m.createNeuron("C"),
                2.0,
                RECTIFIED_HYPERBOLIC_TANGENT_KEY,
                INeuron.Type.EXCITATORY,
                new Synapse.Builder()
                        .setNeuron(inC)
                        .setWeight(10.0)
                        .setBias(-10.0)
                        .setRecurrent(false)
                        .setRangeMatch(Range.Relation.EQUALS)
                        .setRangeOutput(true),
                new Synapse.Builder()
                        .setNeuron(inhibN)
                        .setWeight(-100.0)
                        .setBias(0.0)
                        .setRecurrent(true)
                        .setRangeMatch(Range.Relation.EQUALS)
        );

        // Finally addInput all the inputs to the suppressing neuron.
        Neuron.init(
                inhibN,
                0.0,
                RECTIFIED_LINEAR_UNIT_KEY,
                INeuron.Type.INHIBITORY,
                new Synapse.Builder()
                        .setNeuron(pA)
                        .setWeight(1.0)
                        .setBias(0.0)
                        .setRecurrent(false)
                        .setRangeMatch(Range.Relation.EQUALS)
                        .setRangeOutput(true),
                new Synapse.Builder()
                        .setNeuron(pB)
                        .setWeight(1.0)
                        .setBias(0.0)
                        .setRecurrent(false)
                        .setRangeMatch(Range.Relation.EQUALS)
                        .setRangeOutput(true),
                new Synapse.Builder()
                        .setNeuron(pC)
                        .setWeight(1.0)
                        .setBias(0.0)
                        .setRecurrent(false)
                        .setRangeMatch(Range.Relation.EQUALS)
                        .setRangeOutput(true)
        );

        Neuron outN = Neuron.init(m.createNeuron("OUT"),
                0.0,
                RECTIFIED_HYPERBOLIC_TANGENT_KEY,
                INeuron.Type.EXCITATORY,
                new Synapse.Builder()
                        .setNeuron(pB)
                        .setWeight(1.0)
                        .setBias(0.0)
                        .setRecurrent(false)
                        .setRangeMatch(Range.Relation.EQUALS)
                        .setRangeOutput(true)
        );

        // Now that the model is complete, apply it to a document.

        Document doc = m.createDocument("foobar", 0);

        // Add input activations starting at char 0 and ending at char 1
        // These inputs will be immediately propagated through the network.
        inA.addInput(doc, 0, 1);
        inB.addInput(doc, 0, 1);
        inC.addInput(doc, 0, 1);

        // Computes the best interpretation
        doc.process();

        System.out.println(doc.activationsToString(true, false, true));

        Assert.assertTrue(pA.getFinalActivations(doc).isEmpty());
        Assert.assertFalse(pB.getFinalActivations(doc).isEmpty());
        Assert.assertTrue(pC.getFinalActivations(doc).isEmpty());

        Assert.assertFalse(outN.getFinalActivations(doc).isEmpty());
        doc.clearActivations();
    }
                </code>
			</pre>

			<pre class="prettyprint">
				<code class="language-java">
// Activation ID - Final Decision - Range - Neuron Label - Relational ID (Word Pos.) - Upper Bound
// - Final Value | Final Weight | Final Norm - Input Value | Target Value

0  - SELECTED - (0,1) - IN-A  - RID:null - UB:1.0   - V:1.0 W:0.0 N:0.0 - IV:1.0
6  - SELECTED - (0,1) - IN-B  - RID:null - UB:1.0   - V:1.0 W:0.0 N:0.0 - IV:1.0
11 - SELECTED - (0,1) - IN-C  - RID:null - UB:1.0   - V:1.0 W:0.0 N:0.0 - IV:1.0
4  - SELECTED - (0,1) - INHIB - RID:null - UB:2.959 - V:1.0 W:0.0 N:0.0
2  - EXCLUDED - (0,1) - A     - RID:null - UB:0.995 -
8  - SELECTED - (0,1) - B     - RID:null - UB:1.0   - V:1.0 W:5.0 N:5.0
13 - EXCLUDED - (0,1) - C     - RID:null - UB:0.964 -
10 - SELECTED - (0,1) - OUT   - RID:null - UB:0.762 - V:0.762 W:0.0 N:0.0

 Final SearchNode:10  WeightSum:W:5.0 N:10.0
				</code>
			</pre>
            </div>

            <br/>
            <br/>

            <h3>Pattern matching example</h3>
            <div class="prettyprint-code">
			<pre class="prettyprint">
				<code class="language-java">
    @Test
    public void testPatternMatching() {
        Model m = new Model();

        Map&lt;Character, Neuron&gt; inputNeurons = new HashMap&lt;&gt;();

        // Create an input neuron and a recurrent neuron for every letter in this example.
        for(char c: new char[] {'a', 'b', 'c', 'd', 'e', 'f'}) {
            Neuron in = m.createNeuron(c + "");

            inputNeurons.put(c, in);
        }

        // Create a pattern neuron with the relational neurons as input. The numbers that are
        // given in the inputs are the recurrent ids (relativeRid) which specify the relative position
        // of the inputs relative to each other. The following flag specifies whether this relativeRid
        // is relative or absolute.
        Neuron pattern = Neuron.init(
                m.createNeuron("BCDE"),
                5.0,
                RECTIFIED_HYPERBOLIC_TANGENT_KEY,
                INeuron.Type.EXCITATORY,
                new Synapse.Builder()
                        .setNeuron(inputNeurons.get('b'))
                        .setWeight(10.0)
                        .setBias(-10.0)
                        .setRecurrent(false)
                        .setRelativeRid(0)
                        .setRangeMatch(Operator.EQUALS, Operator.GREATER_THAN_EQUAL)
                        .setRangeOutput(true, false),
                new Synapse.Builder()
                        .setNeuron(inputNeurons.get('c'))
                        .setWeight(10.0)
                        .setBias(-10.0)
                        .setRecurrent(false)
                        .setRelativeRid(1)
                        .setRangeMatch(Range.Relation.CONTAINS),
                new Synapse.Builder()
                        .setNeuron(inputNeurons.get('d'))
                        .setWeight(10.0)
                        .setBias(-10.0)
                        .setRecurrent(false)
                        .setRelativeRid(2)
                        .setRangeMatch(Range.Relation.CONTAINS),
                new Synapse.Builder()
                        .setNeuron(inputNeurons.get('e'))
                        .setWeight(10.0)
                        .setBias(-10.0)
                        .setRecurrent(false)
                        .setRelativeRid(3)
                        .setRangeMatch(Operator.LESS_THAN_EQUAL, Operator.EQUALS)
                        .setRangeOutput(false, true)
        );


        // Create a simple text document.
        Document doc = m.createDocument("a b c d e ", 0);

        // Then add the characters
        int wordPos = 0;
        for(int i = 0; i < doc.length(); i++) {
            char c = doc.getContent().charAt(i);
            if(c != ' ') {
                inputNeurons.get(c).addInput(doc, i, i + 1, wordPos);
            } else {
                wordPos++;
            }
        }

        // Computes the best interpretation
        doc.process();

        Assert.assertEquals(1, pattern.get().getThreadState(doc.threadId, true).activations.size());


        System.out.println("Output activation:");
        INeuron n = pattern.get();
        for(NodeActivation act: n.getActivations(doc)) {
            System.out.println("Text Range: " + act.key.range);
            System.out.println("Node: " + act.key.node);
            System.out.println("Rid: " + act.key.rid);
            System.out.println();
        }

        System.out.println("All activations:");
        System.out.println(doc.activationsToString(true, false, true));
        System.out.println();

        doc.clearActivations();
    }
				</code>
			</pre>
            </div>

            <div class="prettyprint-code">
            <pre class="prettyprint">
				<code class="language-java">
Output activation:
Text Range: (2,9)
Node: BCDE - OR[0:AND[(-1:I[3,b|),(1:I|5,c|),(2:I|7,d|),(3:I|9,e])]]
Rid: 1

All activations:
//Activation ID - Final Decision - Range - Neuron Label - Relational ID (Word Pos.)
//- Upper Bound - Final Value | Final Weight | Final Norm - Input Value | Target Value

0  - SELECTED - (0,1) - a    - RID:0 - UB:1.0 - V:1.0 W:0.0 N:0.0 - IV:1.0
1  - SELECTED - (2,3) - b    - RID:1 - UB:1.0 - V:1.0 W:0.0 N:0.0 - IV:1.0
20 - SELECTED - (2,9) - BCDE - RID:1 - UB:1.0 - V:1.0 W:0.0 N:0.0
3  - SELECTED - (4,5) - c    - RID:2 - UB:1.0 - V:1.0 W:0.0 N:0.0 - IV:1.0
6  - SELECTED - (6,7) - d    - RID:3 - UB:1.0 - V:1.0 W:0.0 N:0.0 - IV:1.0
11 - SELECTED - (8,9) - e    - RID:4 - UB:1.0 - V:1.0 W:0.0 N:0.0 - IV:1.0

 Final SearchNode:1  WeightSum:W:0.0 N:0.0
				</code>
			</pre>
            </div>
        </div>
	</div>
</body>
</html>